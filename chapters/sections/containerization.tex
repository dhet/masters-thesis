\pagebreak
\section{Containerization}
In recent years, container technology has gained widespread adoption in the software development world. By providing light-weight, portable execution environments for applications, containers greatly simplify the software development and deployment workflow, and thus have become a cornerstone of modern software architectures.

\subsection{Comparison to Virtual Machines}
Containerization is also known as ``operating-system-level virtualization'' \cite{soltesz2007container}, and thereby disassociates itself from traditional virtualization technologies such as virtual machines. A major difference between the two is that containerization does not rely on an intermediate virtualization layer between application and hardware, whereas VMs employ hypervisors for this purpose. Hypervisors make it possible to run entire operating systems in their own, isolated environments, so-called VM instances. Several instances may run on the same host machine side-by-side without affecting one another, which allows for the realization of multi-tenant systems. Since hypervisors abstract the substrate hardware, a layer of indirection between hardware and the application to be executed is added. The consequence of this is a considerable overhead, compared to native execution. Containers, in contrast, run directly on the host's kernel and thus exhibit near-native performance (\cite{adufu2015container, felter2015updated, morabito2015hypervisors}). This approach, however, bears security issues~\cite{xavier2013performance}.

As mentioned, each VM instance contains its own operating system and kernel. As a consequence, the disk space requirements for VMs are comparatively high. Additionally, the guest OS within a VM needs to be booted into before being operational, which slows down the VM's start-up speed. Containers, in contrast, do not include their own OSes and kernels. Thus, container start-up can be performed in a matter of milliseconds and is more akin to spawning a process, rather than booting an OS. This enables them to be created and destroyed depending on situational demand, which allows for the implementation of highly elastically scaling systems.
%The recently emerged Function as a Service (FaaS) paradigm popularized by Amazon's cloud offering, AWS Lambda\footnote{\url{aws.amazon.com/de/lambda}}, even suggests to run an ephemeral container for each \emph{request}
Considering their advantages over hypervisor-based virtualization, such near-native performance, sub-second boot times, minimal disk space usage and their energy efficiency \cite{morabito2015power}, containers bring qualities to the table that are relevant especially to embedded systems, which are, by their very nature, resource-constrained. Unsurprisingly, the possibility of leveraging containerization in embedded environments has received substantial attention in recent years (\eg\  \cite{bellavista2017feasibility, javed2016container, morabito2017virtualization}).

Containerization and virtual machines are often regarded as competing virtualization technologies. However, both are not mutually exclusive. In fact, most IaaS providers base their infrastructure on traditional VMs, which then, in turn, host container runtimes~\cite{dua2014virtualization}. Containers and VMs shall thus be seen as complementary, rather than competing, technologies.

\subsection{Container Internals}
Like virtual machines, containers aim to isolate processes from their environment. In the case of containers, isolation is achieved by a kernel feature called \emph{kernel namespaces}.\footnote{\url{www.man7.org/linux/man-pages/man7/namespaces.7.html}} Namespaces wrap global system resources, such as network devices and mount points, and present them to processes as if they were dedicated to them.
When a process runs in the context of a certain namespace, its access and view is limited to that namespace.
There are seven types of namespaces, each of which isolates a different aspect of the host system.
An example for this are \emph{process} namespaces which allow for the creation of alternative views on the process tree. For instance, consider a hypothetical process with PID 345. By assigning a process namespace to that process, it can be led to believe that it has the PID 1 and is the only process running on the system. Thus, the processes' view on other processes is restricted, and since a process can only access what it can see, isolation is achieved.
In a similar way, a processes' access to networks interfaces, the file system, user groups and other parts of the host system can be restricted.

In addition to providing isolation, containers employ resource management mechanisms which make it possible to allocate and limit the resources available to them. Resource management for containers is implemented by a kernel feature called \emph{control groups}, or \emph{cgroups}\footnote{\url{www.man7.org/linux/man-pages/man7/cgroups.7.html}} in short. Cgroups allow for the organization of processes in hierarchical groups. On these groups, resource constraints can be imposed (\eg\ CPU-time, access to devices, memory budget, etc.).
Through this mechanism, processes can be bundled together, effectively forming \emph{containerized process trees}, which can be restricted in what they can do and which resources they may take up. This opens up the possibility for container engines to exert fine-grained control over each processes' resource utilization and to further isolate processes from the rest of the system.

The two concepts (namespaces and cgroups) can be applied individually to any given process running on a Linux system. Only when combined together, such that processes are isolated through namespaces and restricted through cgroups, we speak of containers. In consideration of this, it becomes clear that a containerized process is not much different from a regular process. Rather, containers should be viewed as processes which are \emph{augmented} by these two concepts.

%Further separation can be achieved through SELinux and AppArmor.

While it is possible to create containers manually utilizing the aforementioned native kernel features, such undertaking is rather cumbersome. For this reason, several tools are being developed which aim to streamline the use of containers. A few notable examples are \emph{\docker},\footnote{\url{www.docker.com}} \emph{RKT},\footnote{\url{www.github.com/rkt/rkt}} \emph{CRI-O},\footnote{\url{www.cri-o.io}} \emph{Railcar}\footnote{\url{www.github.com/oracle/railcar}} and \emph{LXC}.\footnote{\url{www.linuxcontainers.org}} Among these,  \docker\ is undoubtedly the most prominent one, and arguably the first one to make Linux containers accessible for general use. As it is the most mature containerization solution, \docker\ was chosen for the approach presented in this thesis.


