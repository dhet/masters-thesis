
\section{Linux Containers}

\begin{itemize}
	\item Why is there a need for virtualization?
\end{itemize}

In recent years, container technology has gained widespread adoption in the software development world. By greatly simplifying the software deploymentâ€” and development workflow, containers have become a cornerstone of successful software architectures.


Considering their advantages over hypervisor-based virtualization, such near native performance, sub-second boot times \cite{felter2015updated,morabito2015hypervisors} and minimal disk space usage, containers bring qualities to the table that are relevant specifically to embedded systems.

Containers are independent units of deployment containing everything a particular application needs to run from system libraries, tools, and runtimes to application specific settings. 
Akin to hypervisor-based virtualization, Linux containers aim to provide isolated, self-contained execution environments for applications that may be moved freely between hosts without affecting the application's behavior.
Unlike traditional virtual machines, however, applications in containers run on non-virtualized hardware, and thereby, with minimal performance overhead when properly configured \cite{felter2015updated,morabito2015hypervisors}. This is of interest particularly in the field of embedded systems where resource constraints are prevalent.

Enabled by a Linux kernel feature called \emph{kernel namespaces}, multiple containers may run on the same host side-by-side without affecting one another, or even having knowledge of each others existence. 
Namespaces wrap a set of system resources and present them to the container process as if they were dedicated to it. Each aspect of a container runs in its own namespace and its access is limited to that namespace. Through this, a decent level of isolation is achieved, albeit not as far-reaching as the isolation provided by VMs. The only thing containers share is the host's OS kernel, and optionally, parts of the file system.

In addition to providing isolation, containers employ resource management mechanisms which make it possible to allocate and limit the resources available to containerized processes. Resource management for containers is implemented by a kernel feature called \emph{control groups}, or \emph{cgroups} in short. Cgroups allow for the imposition of resource constraints (CPU-time, access to devices, memory budget, etc.) for groups of processes. Through this mechanism, containers, effectively \emph{being} groups of processes, can be restricted in what they can do and which resources they may take up. This opens up the possibility for container engines to exert fine-grained control over each container's resource utilization.

The two concepts (namespaces and cgroups) can be applied individually to any given process running on a Linux system. Only when combined together, such that processes are isolated through namespaces and restricted through cgroups, we speak of containers. In consideration of this it becomes clear that there is no clear distinction between a container and a process. Much rather, containers should be viewed as processes which are augmented by these two concepts.

%Further separation can be achieved through SELinux and AppArmor.

While it is possible to create containers manually utilizing the aforementioned native kernel features, such undertaking is rather cumbersome. For this reason, several tools are being developed which aim to streamline the use of containers. A few notable examples are \emph{\docker}\footnote{\url{www.docker.com}}, \emph{RKT}\footnote{\url{www.github.com/rkt/rkt}}, \emph{CRI-O}\footnote{\url{www.cri-o.io}}, \emph{Railcar}\footnote{\url{www.github.com/oracle/railcar}} and \emph{LXC}\footnote{\url{www.linuxcontainers.org}}. Among these,  \docker\ is undoubtedly the most prominent one, and arguably the first one to make Linux containers accessible for general use. For this reason, \docker\ was chosen for the approach presented in this thesis. Hence, the concepts described in the following are centered around \docker . 

\subsection{\docker\ Images}
Unique to \docker\ is its approach to container images. Images may be seen as the "blueprint" on the basis of which containers are built. Images are implemented utilizing UnionFS, a Linux service that facilitates the layering of different file systems atop each other. 
Leveraging this technology, \docker\ images are made of layers, with each layer adding to, or modifying, the respective underlying layer. 

Layers are immutable, such that, \eg , a file created in an underlying layer may not be deleted. Instead, when a change in the file system is performed, a copy-on-write layers is created, effectively adding another layer to the image.

A benefit of this approach is that individual layers may be shared and reused in other containers, thereby saving tremendous amounts of disk space compared to traditional VM images.

\subsection{\docker\ Engine}
The engine takes a container image and turns it into a container, \ie , a running process.

the engine can be controlled by means of a RESTful API. Most commonly, the engine is controlled by a command-line interface which makes calls to that API.

\subsection{Image Registries}

\subsection{\docker\ Networking}


% https://thenewstack.io/container-networking-breakdown-explanation-analysis/

\emph{libnetwork}

\docker\ provides several methods to create network links between containers.  



\paragraph{Bridge.} By default, \docker\ connects containers via a Linux bridge. Bridges are host-internal network interfaces. Through \texttt{iptables} functions like NAT\footnote{Network Address Translation} and port mapping are facilitated.

\paragraph{Host.} A Container in \emph{host} mode takes over the network interface of the host system. Therefore, all capabilities that that the host system possesses also apply to that container. A disadvantage of this is that only one container may run on a given host at any time.

\paragraph{Overlay.} 
Overlay networks \cite{tarkoma2010overlay} are ...
VXLAN as tunneling technology.
Serf as gossip protocol.
Implementations: flannel.
Benefits: Cross cloud connectivity, no public ports.

\paragraph{Underlay.}
MACvlan: Separate MAC and IP address assigned to each container. Eliminates the need for bridges and NAT, making it performant. Containers are entirely isolated from the host, increasing security.
IPvlan: Similar to MACvlan but instead of having one MAC address per container, all containers on a host share the same address. This works around a common security measure in network switches to prohibit the use of multiple MAC addresses per physical port.
