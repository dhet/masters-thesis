
\section{Linux Containers}

\begin{itemize}
	\item Why is there a need for virtualization?
\end{itemize}

In recent years, container technology has gained widespread adoption in the software development world. By greatly simplifying the software deploymentâ€” and development workflow, containers have become a cornerstone of successful software architectures.


Considering their advantages over hypervisor-based virtualization, such near native performance, sub-second boot times \cite{felter2015updated,morabito2015hypervisors} and minimal disk space usage, containers bring qualities to the table that are relevant specifically to embedded systems.

Containers are independent units of deployment containing everything a particular application needs to run from system libraries, tools, and runtimes to application specific settings. 
Akin to hypervisor-based virtualization, Linux containers aim to provide isolated, self-contained execution environments for applications that may be moved freely between hosts without affecting the application's behavior.
Unlike traditional virtual machines, however, applications in containers run on non-virtualized hardware, and thereby, with minimal performance overhead when properly configured \cite{felter2015updated,morabito2015hypervisors}. This is of interest particularly in the field of embedded systems where resource constraints are prevalent.

Like virtual machines, containers aim to isolate processes from their environment. In the case of containers, isolation is achieved by a kernel feature called \emph{kernel namespaces}\footnote{\url{www.man7.org/linux/man-pages/man7/namespaces.7.html}}. Namespaces wrap global system resources, such as network devices and mount points, and present them to processes as if they were dedicated to them. 
When a process runs in the context of a certain namespace, its access and view is limited to that namespace. 
There are seven types of namespaces, each of which isolates a different aspect of the host system. 
An example for this are \emph{process namespaces} which allow for the creation of alternative views on the process tree. A hypothetical process with PID 345 may be assigned a process namespace which makes the process believe that it had the PID 1 and was the only process running on the system. 
In a similar way, a processes' access to networks interfaces, the file system, user groups and other parts of the host system can be restricted.

%The only thing containers share is the host's OS kernel, and optionally, parts of the file system.

In addition to providing isolation, containers employ resource management mechanisms which make it possible to allocate and limit the resources available to them. Resource management for containers is implemented by a kernel feature called \emph{control groups}, or \emph{cgroups}\footnote{\url{www.man7.org/linux/man-pages/man7/cgroups.7.html}} in short. Cgroups allow for the organization of processes in hierarchical groups. On these groups, resource constraints can be imposed (\eg\ CPU-time, access to devices, memory budget, etc.). 
%the imposition of resource constraints (CPU-time, access to devices, memory budget, etc.) for groups of processes. 
Through this mechanism, processes can be bundled together, effectively forming \emph{containers}, which can be restricted in what they can do and which resources they may take up. This opens up the possibility for container engines to exert fine-grained control over each container's resource utilization.

The two concepts (namespaces and cgroups) can be applied individually to any given process running on a Linux system. Only when combined together, such that processes are isolated through namespaces and restricted through cgroups, we speak of containers. In consideration of this it becomes clear that a containerized process is not much different from a regular process. Rather, containers should be viewed as processes which are augmented by these two concepts.

%Further separation can be achieved through SELinux and AppArmor.

While it is possible to create containers manually utilizing the aforementioned native kernel features, such undertaking is rather cumbersome. For this reason, several tools are being developed which aim to streamline the use of containers. A few notable examples are \emph{\docker}\footnote{\url{www.docker.com}}, \emph{RKT}\footnote{\url{www.github.com/rkt/rkt}}, \emph{CRI-O}\footnote{\url{www.cri-o.io}}, \emph{Railcar}\footnote{\url{www.github.com/oracle/railcar}} and \emph{LXC}\footnote{\url{www.linuxcontainers.org}}. Among these,  \docker\ is undoubtedly the most prominent one, and arguably the first one to make Linux containers accessible for general use. As it is the most mature containerization solution, \docker\ was chosen for the approach presented in this thesis.


